---
layout: post
title: Algorithm---8 Puzzle(Priority Queues)
categories: [blog ]
tags: [study,java,sort,priorityQueue ]
description: Good algorithm is much more efficienet than spending more money and time
---  

In the assignment, it introduces an algorithm----A*, after checking it, I just realized
how widely use it is.
**A*(A star)** is a computer algorithm widely used in pathfinding and graph traversal.   
The simplest (and least efficient) method of traversing a graph is the **Depth First Search**   
(an algorithm starts at the root and explores as far as possible along each branch before    
backtracking. In some area, the graph to be traversed is often either too large to visit  
in its entirety or infinite, then DFS will suffer non-termination).  

Pathfinders enable us to plan ahead rather than waiting until the last moment to discover   
there is a problem.

**backtrack**   
In backtracking algorithms, try to build one step at a time. If at some step it become clear
that the current path that you are on cannot lead to a solution you go back to. Common example   
is Eight qqueens puzzle:
    queens = [0,0...,0]
    for i=1 to maxRows:
        for j=1 to maxRows:
            queens[i] = queens[i]++
            if queensNotUnderAttack(i) then:
                break
            else :
                if j == maxRows then: i--

[![situation without using proper algorithm](http://imgur.com/VWcbNF9 "situation without using proper algorithm")](http://imgur.com/VWcbNF9 "situation without using proper algorithm")
[![extend a movement algorithm](http://imgur.com/fWX98sa "extend a movement algorithm")](http://imgur.com/fWX98sa "extend a movement algorithm")

Dijikstra's algorithm works well to find the shorted path, but it wastes time in exploring directions  
that aren't promising. Greedy Best First Search algorithm selects the vertex closest to the goal, exploring  
in promising directions but it may not find the shortest path. The A* algorithm uses both the actual    
distance from the start and the estimated distance to the goal.  

Compare the algorithms: Dijkstraâ€™s Algorithm calculates the distance from the start point. Greedy   
Best-First Search estimates the distance to the goal point. A* is using the sum of those two distances.  

[reference1](http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html)
#### Notes  
(1)To calculate Manhattan priority is to calculate the sum of the distance in vertical and horizontal.
(2)Unsolvable case: if the initial board can become into global board by swapping any pair of blocks.(prove!)
(3)The length of 2 dimension array:   
     public static void main(String[] args) {
    
        int[][] foo = new int[][] {
            new int[] { 1, 2, 3 },
            new int[] { 1, 2, 3, 4},
        };
    
        System.out.println(foo.length); //2
        System.out.println(foo[0].length); //3
        System.out.println(foo[1].length); //4
    }

#### Problems    
1. how to create priority queue and game tree, in this case, one board cann have more than 2 neighbors,   
how to express this or should use not binary tree? To construct priority queue, should have the key, should
the priority be the key? If this, how to find the right path under the condition that parent is not real parant?

2. decide unsolvable puzzles, how to solve the "any"?

#### Mistakes
1.  The operator == is undefined for the argument type(s) int, null:  

Primitive types(int here) in Java cannot be null. If you want to check for 0, do a != 0.  
int cannot be compared to null, which is a null reference to an object  
Similarly, cannot invoke equals(int) on the primitive type int

