---
layout: post
title: Algorithm---8 Puzzle(Priority Queues)
categories: [blog ]
tags: [study,java,sort,priorityQueue ]
description: Good algorithm is much more efficienet than spending more money and time
---  

In the assignment, it introduces an algorithm----A*, after checking it, I just realized
how widely use it is.
**A*(A star)** is a computer algorithm widely used in pathfinding and graph traversal.   
The simplest (and least efficient) method of traversing a graph is the **Depth First Search**   
(an algorithm starts at the root and explores as far as possible along each branch before    
backtracking. In some area, the graph to be traversed is often either too large to visit  
in its entirety or infinite, then DFS will suffer non-termination).  

Pathfinders enable us to plan ahead rather than waiting until the last moment to discover   
there is a problem.

**backtrack**   
In backtracking algorithms, try to build one step at a time. If at some step it become clear
that the current path that you are on cannot lead to a solution you go back to. Common example   
is Eight qqueens puzzle:
    queens = [0,0...,0]
    for i=1 to maxRows:
        for j=1 to maxRows:
            queens[i] = queens[i]++
            if queensNotUnderAttack(i) then:
                break
            else :
                if j == maxRows then: i--

[![situation without using proper algorithm](http://imgur.com/VWcbNF9 "situation without using proper algorithm")](http://imgur.com/VWcbNF9 "situation without using proper algorithm")
[![extend a movement algorithm](http://imgur.com/fWX98sa "extend a movement algorithm")](http://imgur.com/fWX98sa "extend a movement algorithm")

Dijikstra's algorithm works well to find the shorted path, but it wastes time in exploring directions  
that aren't promising. Greedy Best First Search algorithm selects the vertex closest to the goal, exploring  
in promising directions but it may not find the shortest path. The A* algorithm uses both the actual    
distance from the start and the estimated distance to the goal.  

Compare the algorithms: Dijkstraâ€™s Algorithm calculates the distance from the start point. Greedy   
Best-First Search estimates the distance to the goal point. A* is using the sum of those two distances.  

[reference1](http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html)
#### Notes  
(1)To calculate Manhattan priority is to calculate the sum of the distance in vertical and horizontal.
(2)Unsolvable case: if the initial board can become into global board by swapping any pair of blocks.(prove!)
(3)The length of 2 dimension array:   
     public static void main(String[] args) {
    
        int[][] foo = new int[][] {
            new int[] { 1, 2, 3 },
            new int[] { 1, 2, 3, 4},
        };
    
        System.out.println(foo.length); //2
        System.out.println(foo[0].length); //3
        System.out.println(foo[1].length); //4
    }

#### Problems    
1. how to create priority queue and game tree, in this case, one board cann have more than 2 neighbors,   
how to express this or should use not binary tree? To construct priority queue, should have the key, should
the priority be the key? If this, how to find the right path under the condition that parent is not real parant?

Analysis:  
Follow the steps: 1st create an inner class called gameNode to which includes current board, previous board,  
isTwin, move num which is enough to trace the solution  
2nd create 1 minPQ which is a binary tree implementation using class methods provided, add the   
initial and the twin of the initial  
3rd using minPQ.delMin() to find the node with lowest priority(sum of manhatton number and moves is smallest)  
which can guarantee smallest move, then check each of its neighbors, add them into the queue then repeat this   
step till find the node A which has board equals to the goal.  
4th check if the attribute isTwin of node A is true, then it meets the unsolvable condition, so no solution.

But still don't understand why that case(after switching any pair of initial can become into goal) is unsolvable  
and why add the twin of initial into queue????

2. decide unsolvable puzzles, how to solve the "any"?

#### Mistakes
1.  The operator == is undefined for the argument type(s) int, null:  

Primitive types(int here) in Java cannot be null. If you want to check for 0, do a != 0.  
int cannot be compared to null, which is a null reference to an object  
Similarly, cannot invoke equals(int) on the primitive type int

2. To exit 2 nest loops  
in java, can use label to specify which loop to break
    mainLoop:
    while (goal <= 100) {
       for (int i = 0; i < goal; i++) {
          if (points > 50) {
             break mainLoop;
          }
          points += i;
       }
    }

3. To create neighbors, I used only one array for 4 cases(left, right, up, down), even though
I added them inside the stack in order, but the content change of array in any neighbor will
influence others, because of the same array

4. My swap method as following is wrong:
        private void swap(int a, int b) {
            int temp = 0;
            temp = a;
            a = b;
            b = temp;
        }
it won't change anything because java is passing-by-value. Instead can do like this:   
    void swap(int[][] array, int row1, int col1, int row2, int col2) {
        int temp = array[row1][col1];
        array[row1][col1] = array[row2][col2];
        array[row2][col2] = temp;
    }

